<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tukekenulia♥</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习安装使用RabbitMQ，安装失败原因未知，暂且搁置。。">
<meta property="og:type" content="article">
<meta property="og:title" content="Tukekenulia♥">
<meta property="og:url" content="http://yoursite.com/2022/05/26/Spring%20Boot%20RabbitMQ/index.html">
<meta property="og:site_name" content="Tukekenulia♥">
<meta property="og:description" content="学习安装使用RabbitMQ，安装失败原因未知，暂且搁置。。">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/Spring-Boot-RabbitMQ/1.png">
<meta property="og:image" content="http://yoursite.com/images/Spring-Boot-RabbitMQ/2.png">
<meta property="og:image" content="http://yoursite.com/images/Spring-Boot-RabbitMQ/3.png">
<meta property="article:published_time" content="2022-05-26T00:54:40.000Z">
<meta property="article:modified_time" content="2022-05-26T00:54:40.000Z">
<meta property="article:author" content="Tukeke">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/Spring-Boot-RabbitMQ/1.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">Tukekenulia♥</div>
      
        <div id="subtitle">Stay focus,stay humble,stay curiosity.</div>
      
       <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/Tukekehaohaonuli" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="YOUR WEIBO HOME PAGE URL" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">Tukekenulia♥</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="yoursite.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring Boot RabbitMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/05/26/Spring%20Boot%20RabbitMQ/" class="article-date">
  <time datetime="2022-05-26T00:54:40.000Z" itemprop="datePublished">2022-05-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习安装使用RabbitMQ，安装失败原因未知，暂且搁置。。</p>
<span id="more"></span>

<h1 id="1-RabbitMQ-的重要概念"><a href="#1-RabbitMQ-的重要概念" class="headerlink" title="1-RabbitMQ 的重要概念"></a>1-RabbitMQ 的重要概念</h1><h3 id="1-1-RabbitMQ-简介"><a href="#1-1-RabbitMQ-简介" class="headerlink" title="1.1 RabbitMQ 简介"></a>1.1 RabbitMQ 简介</h3><p>RabbitMQ 是采用 Erlang 语言实现 AMQP(Advanced Message Queuing Protocol，高级消息队列协议）的消息中间件，它最初起源于金融系统，用于在分布式系统中存储转发消息。</p>
<p>特点：</p>
<ul>
<li><strong>可靠性：</strong> RabbitMQ使用一些机制来保证消息的可靠性，如持久化、传输确认及发布确认等。</li>
<li><strong>灵活的路由：</strong> 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能，RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个交换器绑定在一起，也可以通过插件机制来实现自己的交换器。</li>
<li><strong>扩展性：</strong> 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展集群中节点。</li>
<li><strong>高可用性：</strong> 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队列仍然可用。</li>
<li><strong>支持多种协议：</strong> RabbitMQ 除了原生支持 AMQP 协议，还支持 STOMP、MQTT 等多种消息中间件协议。</li>
<li><strong>多语言客户端：</strong> RabbitMQ几乎支持所有常用语言，比如 Java、Python、Ruby、PHP、C#、JavaScript等。</li>
<li><strong>易用的管理界面：</strong> RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息、集群中的节点等。在安装 RabbitMQ 的时候会介绍到，安装好 RabbitMQ 就自带管理界面。</li>
<li><strong>插件机制：</strong> RabbitMQ 提供了许多插件，以实现从多方面进行扩展，当然也可以编写自己的插件。感觉这个有点类似 Dubbo 的 SPI机制。</li>
</ul>
<h3 id="1-2-RabbitMQ-核心概念"><a href="#1-2-RabbitMQ-核心概念" class="headerlink" title="1.2 RabbitMQ 核心概念"></a>1.2 RabbitMQ 核心概念</h3><p>RabbitMQ 整体上是一个生产者与消费者模型，主要负责接收、存储和转发消息。可以把消息传递的过程想象成：当你将一个包裹送到邮局，邮局会暂存并最终将邮件通过邮递员送到收件人的手上，RabbitMQ就好比由邮局、邮箱和邮递员组成的一个系统。从计算机术语层面来说，RabbitMQ 模型更像是一种交换机模型。</p>
<h4 id="1-2-1-Producer-生产者-和-Consumer-消费者"><a href="#1-2-1-Producer-生产者-和-Consumer-消费者" class="headerlink" title="1.2.1 Producer(生产者) 和 Consumer(消费者)"></a>1.2.1 Producer(生产者) 和 Consumer(消费者)</h4><ul>
<li><strong>Producer(生产者)</strong> :生产消息的一方（邮件投递者）</li>
<li><strong>Consumer(消费者)</strong> :消费消息的一方（邮件收件人）</li>
</ul>
<p>消息一般由 2 部分组成：<strong>消息头</strong>（或者说是标签 Label）和 <strong>消息体</strong>。消息体也可以称为 payLoad ,消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。生产者把消息交由 RabbitMQ 后，RabbitMQ 会根据消息头把消息发送给感兴趣的 Consumer(消费者)。</p>
<h4 id="1-2-2-Exchange-交换器"><a href="#1-2-2-Exchange-交换器" class="headerlink" title="1.2.2 Exchange(交换器)"></a>1.2.2 Exchange(交换器)</h4><p>在 RabbitMQ 中，消息并不是直接被投递到 <strong>Queue(消息队列)</strong> 中的，中间还必须经过 <strong>Exchange(交换器)</strong> 这一层，<strong>Exchange(交换器)</strong> 会把我们的消息分配到对应的 <strong>Queue(消息队列)</strong> 中。</p>
<p><strong>Exchange(交换器)</strong> 用来接收生产者发送的消息并将这些消息路由给服务器中的队列中，如果路由不到，或许会返回给 <strong>Producer(生产者)</strong> ，或许会被直接丢弃掉 。这里可以将RabbitMQ中的交换器看作一个简单的实体。</p>
<p><strong>RabbitMQ 的 Exchange(交换器) 有4种类型，不同的类型对应着不同的路由策略</strong>：<strong>direct(默认)<strong>，</strong>fanout</strong>, <strong>topic</strong>, 和 <strong>headers</strong>，不同类型的Exchange转发消息的策略有所区别。</p>
<p>生产者将消息发给交换器的时候，一般会指定一个 **RoutingKey(路由键)**，用来指定这个消息的路由规则，而这个 <strong>RoutingKey 需要与交换器类型和绑定键(BindingKey)联合使用才能最终生效</strong>。</p>
<p>RabbitMQ 中通过 <strong>Binding(绑定)</strong> 将 <strong>Exchange(交换器)</strong> 与 <strong>Queue(消息队列)</strong> 关联起来，在绑定的时候一般会指定一个 <strong>BindingKey(绑定建)</strong> ,这样 RabbitMQ 就知道如何正确将消息路由到队列了,如下图所示。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。Exchange 和 Queue 的绑定可以是多对多的关系。</p>
<p>生产者将消息发送给交换器时，需要一个RoutingKey,当 BindingKey 和 RoutingKey 相匹配时，消息会被路由到对应的队列中。在绑定多个队列到同一个交换器的时候，这些绑定允许使用相同的 BindingKey。BindingKey 并不是在所有的情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视，而是将消息路由到所有绑定到该交换器的队列中。</p>
<h4 id="1-2-3-Queue-消息队列"><a href="#1-2-3-Queue-消息队列" class="headerlink" title="1.2.3 Queue(消息队列)"></a>1.2.3 Queue(消息队列)</h4><p><strong>Queue(消息队列)</strong> 用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
<p><strong>RabbitMQ</strong> 中消息只能存储在 <strong>队列</strong> 中，这一点和 <strong>Kafka</strong> 这种消息中间件相反。Kafka 将消息存储在 <strong>topic（主题）</strong> 这个逻辑层面，而相对应的队列逻辑只是topic实际存储文件中的位移标识。 RabbitMQ 的生产者生产消息并最终投递到队列中，消费者可以从队列中获取消息并消费。</p>
<p><strong>多个消费者可以订阅同一个队列</strong>，这时队列中的消息会被平均分摊（Round-Robin，即轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理，这样避免的消息被重复消费。</p>
<p><strong>RabbitMQ</strong> 不支持队列层面的广播消费,如果有广播消费的需求，需要在其上进行二次开发,这样会很麻烦，不建议这样做。</p>
<h4 id="1-2-4-Broker（消息中间件的服务节点）"><a href="#1-2-4-Broker（消息中间件的服务节点）" class="headerlink" title="1.2.4 Broker（消息中间件的服务节点）"></a>1.2.4 Broker（消息中间件的服务节点）</h4><p>对于 RabbitMQ 来说，一个 RabbitMQ Broker 可以简单地看作一个 RabbitMQ 服务节点，或者RabbitMQ服务实例。大多数情况下也可以将一个 RabbitMQ Broker 看作一台 RabbitMQ 服务器。</p>
<h4 id="1-2-5-Exchange-Types-交换器类型"><a href="#1-2-5-Exchange-Types-交换器类型" class="headerlink" title="1.2.5 Exchange Types(交换器类型)"></a>1.2.5 Exchange Types(交换器类型)</h4><p>RabbitMQ 常用的 Exchange Type 有 <strong>fanout</strong>、<strong>direct</strong>、<strong>topic</strong>、<strong>headers</strong> 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与 自定义，这里不予以描述）。</p>
<h5 id="①-fanout"><a href="#①-fanout" class="headerlink" title="① fanout"></a>① fanout</h5><p>fanout 类型的Exchange路由规则非常简单，它会把所有发送到该Exchange的消息路由到所有与它绑定的Queue中，不需要做任何判断操作，所以 fanout 类型是所有的交换机类型里面速度最快的。fanout 类型常用来广播消息。</p>
<h5 id="②-direct"><a href="#②-direct" class="headerlink" title="② direct"></a>② direct</h5><p>direct 类型的Exchange路由规则也很简单，它会把消息路由到那些 Bindingkey 与 RoutingKey 完全匹配的 Queue 中。</p>
<p>direct 类型常用在处理有优先级的任务，根据任务的优先级把消息发送到对应的队列，这样可以指派更多的资源去处理高优先级的队列。</p>
<h5 id="③-topic"><a href="#③-topic" class="headerlink" title="③ topic"></a>③ topic</h5><p>前面讲到direct类型的交换器路由规则是完全匹配 BindingKey 和 RoutingKey ，但是这种严格的匹配方式在很多情况下不能满足实际业务的需求。topic类型的交换器在匹配规则上进行了扩展，它与 direct 类型的交换器相似，也是将消息路由到 BindingKey 和 RoutingKey 相匹配的队列中，但这里的匹配规则有些不同，它约定：</p>
<ul>
<li>RoutingKey 为一个点号“．”分隔的字符串（被点号“．”分隔开的每一段独立的字符串称为一个单词），如 “com.rabbitmq.client”、“java.util.concurrent”、“com.hidden.client”;</li>
<li>BindingKey 和 RoutingKey 一样也是点号“．”分隔的字符串；</li>
<li>BindingKey 中可以存在两种特殊字符串“<em>”和“#”，用于做模糊匹配，其中“</em>”用于匹配一个单词，“#”用于匹配多个单词(可以是零个)。</li>
</ul>
<h5 id="④-headers-不推荐"><a href="#④-headers-不推荐" class="headerlink" title="④ headers(不推荐)"></a>④ headers(不推荐)</h5><p>headers 类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的 headers 属性进行匹配。在绑定队列和交换器时制定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的 headers（也是一个键值对的形式)’对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers 类型的交换器性能会很差，而且也不实用，基本上不会看到它的存在。</p>
<h1 id="2-RabbitMQ安装"><a href="#2-RabbitMQ安装" class="headerlink" title="2-RabbitMQ安装"></a>2-RabbitMQ安装</h1><p>RabbitMQ 是由 Erlang语言编写的，也正因如此，在安装RabbitMQ 之前需要安装 Erlang。</p>
<p>RabiitMQ和Erlang的版本对应关系：<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p>安装至 &#x2F;usr&#x2F;local&#x2F;src</p>
<h3 id="2-1-安装-erlang"><a href="#2-1-安装-erlang" class="headerlink" title="2.1 安装 erlang"></a>2.1 安装 erlang</h3><p><strong>1 下载 erlang 安装包</strong></p>
<p>在官网下载然后上传到 Linux 上或者直接使用下面的命令下载对应的版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#wget http://erlang.org/download/otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure>

<p>erlang 官网下载：<a target="_blank" rel="noopener" href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a></p>
<p><strong>2 解压 erlang 安装包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#tar -xvzf otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>3 删除 erlang 安装包</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#rm -rf otp_src_19.3.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>4 安装 erlang 的依赖工具</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]#yum -y install make gcc gcc-c++ kernel-devel m4 ncurses-devel openssl-devel unixODBC-devel</span><br></pre></td></tr></table></figure>

<p><strong>5 进入erlang 安装包解压文件对 erlang 进行安装环境的配置</strong></p>
<p>新建一个文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb local]# mkdir erlang</span><br></pre></td></tr></table></figure>

<p>对 erlang 进行安装环境的配置</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# </span><br><span class="line">./configure --prefix=/usr/local/erlang --without-javac</span><br></pre></td></tr></table></figure>

<p><strong>6 编译安装</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# </span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p><strong>7 验证一下 erlang 是否安装成功了</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb otp_src_19.3]# ./bin/erl</span><br></pre></td></tr></table></figure>

<p>运行下面的语句输出“hello world”</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io:format(&quot;hello world~n&quot;, []).</span><br></pre></td></tr></table></figure>

<p><strong>8 配置 erlang 环境变量</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# vim profile</span><br></pre></td></tr></table></figure>

<p>追加下列环境变量到文件末尾</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#erlang</span><br><span class="line">ERL_HOME=/usr/local/erlang</span><br><span class="line">PATH=$ERL_HOME/bin:$PATH</span><br><span class="line">export ERL_HOME PATH</span><br></pre></td></tr></table></figure>

<p>运行下列命令使配置文件<code>profile</code>生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# source /etc/profile</span><br></pre></td></tr></table></figure>

<p>输入 erl 查看 erlang 环境变量是否配置正确</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@SnailClimb etc]# erl</span><br></pre></td></tr></table></figure>

<p><img src="/../images/Spring-Boot-RabbitMQ/1.png" alt="1"></p>
<h3 id="2-2-安装-RabbitMQ"><a href="#2-2-安装-RabbitMQ" class="headerlink" title="2.2 安装 RabbitMQ"></a>2.2 安装 RabbitMQ</h3><p>安装失败。。</p>
<h1 id="3-Spring-Boot-RabbitMQ（未读）"><a href="#3-Spring-Boot-RabbitMQ（未读）" class="headerlink" title="3-Spring Boot RabbitMQ（未读）"></a>3-Spring Boot RabbitMQ（未读）</h1><h3 id="RabbitMQ-介绍"><a href="#RabbitMQ-介绍" class="headerlink" title="RabbitMQ 介绍"></a>RabbitMQ 介绍</h3><p>AMQP（Advanced Message Queuing Protocol，高级消息队列协议）是应用层协议的一个开放标准，为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。</p>
<p>AMQP 的主要特征是面向消息、队列、路由（包括点对点和发布&#x2F;订阅）、可靠性、安全。</p>
<p>RabbitMQ 是一个开源的 AMQP 实现，服务器端用 Erlang 语言编写，支持多种客户端，如 Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP 等，支持 AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p>通常我们谈到队列服务，会有三个概念：发消息者、队列、收消息者。RabbitMQ 在这个基本概念之上，多做了一层抽象，在发消息者和队列之间加入了交换器（Exchange）。这样发消息者和队列就没有直接联系，转而变成发消息者把消息给交换器，交换器根据调度策略再把消息再给队列。</p>
<p><img src="/images/Spring-Boot-RabbitMQ/2.png" alt="2"></p>
<ul>
<li>左侧 P 代表生产者，也就是往 RabbitMQ 发消息的程序。</li>
<li>中间即是 RabbitMQ，其中包括了交换机和队列。</li>
<li>右侧 C 代表消费者，也就是往 RabbitMQ 拿消息的程序。</li>
</ul>
<p>那么，其中比较重要的概念有 4 个，分别为：虚拟主机、交换机、队列和绑定。</p>
<ul>
<li>虚拟主机：一个虚拟主机持有一组交换机、队列和绑定，为什么需要多个虚拟主机呢？很简单，RabbitMQ 当中，<strong>用户只能在虚拟主机的粒度进行权限控制</strong>。因此，如果需要禁止 A 组访问 B 组的交换机&#x2F;队列&#x2F;绑定，必须为 A 和 B 分别创建一个虚拟主机，每一个 RabbitMQ 服务器都有一个默认的虚拟主机“&#x2F;”。</li>
<li>交换机：Exchange 用于转发消息，但是它不会做存储，如果没有 Queue bind 到 Exchange 的话，它会直接丢弃掉 Producer 发送过来的消息。</li>
</ul>
<blockquote>
<p>这里有一个比较重要的概念：<strong>路由键</strong> 。消息到交换机的时候，交互机会转发到对应的队列中，那么究竟转发到哪个队列，就要根据该路由键。</p>
</blockquote>
<ul>
<li>绑定：也就是交换机需要和队列相绑定，这其中如上图所示，是多对多的关系。</li>
</ul>
<h4 id="交换机（Exchange）"><a href="#交换机（Exchange）" class="headerlink" title="交换机（Exchange）"></a>交换机（Exchange）</h4><p>交换机的功能主要是接收消息并且转发到绑定的队列，交换机不存储消息，在启用 ack 模式后，交换机找不到队列，会返回错误。交换机有四种类型：Direct、topic、Headers and Fanout。</p>
<ul>
<li>Direct：其类型的行为是“先匹配、再投送”，即在绑定时设定一个 <strong>routing_key</strong>，消息的 <strong>routing_key</strong> 匹配时，才会被交换器投送到绑定的队列中去。</li>
<li>Topic：按规则转发消息（最灵活）。</li>
<li>Headers：设置 header attribute 参数类型的交换机。</li>
<li>Fanout：转发消息到所有绑定队列。</li>
</ul>
<p><strong>Direct Exchange</strong></p>
<p>Direct Exchange 是 RabbitMQ 默认的交换机模式，也是最简单的模式，根据 key 全文匹配去寻找队列。</p>
<p><img src="/images/Spring-Boot-RabbitMQ/3.png" alt="3"></p>
<p>第一个 X - Q1 就有一个 binding key，名字为 orange；X - Q2 就有 2 个 binding key，名字为 black 和 green。当消息中的<strong>路由键</strong>和这个 binding key 对应上的时候，那么就知道了该消息去到哪一个队列中。</p>
<blockquote>
<p>注意：为什么 X 到 Q2 要有 black、green，2 个 binding key 呢，一个不就行了吗？这个主要是因为可能又有 Q3，而 Q3 只接收 black 的信息，而 Q2 不仅接收 black 的信息，还接收 green 的信息。</p>
</blockquote>
<p><strong>Topic Exchange</strong></p>
<p>Topic Exchange 转发消息主要是根据通配符。在这种交换机下，队列和交换机的绑定会定义一种路由模式，那么，通配符就要在这种路由模式和路由键之间匹配后交换机才能转发消息。</p>
<p>在这种交换机模式下：</p>
<ul>
<li>路由键必须是一串字符，用句号（.）隔开，比如 agreements.us，或者 agreements.eu.stockholm 等；</li>
<li>路由模式必须包含一个 星号（* ），主要用于匹配路由键指定位置的一个单词，比如，一个路由模式是这样子，agreements..b.*，那么就只能匹配路由键是这样子的，第一个单词是 agreements，第四个单词是 b；井号（#）就表示相当于一个或者多个单词，例如一个匹配模式是 agreements.eu.berlin.#，那么，以 agreements.eu.berlin 开头的路由键都是可以的。</li>
</ul>
<p>具体代码发送的时候还是一样，第一个参数表示交换机，第二个参数表示 routing key，第三个参数即消息。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rabbitTemplate.convertAndSend(&quot;testTopicExchange&quot;,&quot;key1.a.c.key2&quot;, &quot; this is  RabbitMQ!&quot;);</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>Topic 和 Direct 类似, 只是匹配上支持了“模式”，在“点分”的 routing_key 形式中, 可以使用两个通配符:</p>
<ul>
<li>* 表示一个词</li>
<li># 表示零个或多个词</li>
</ul>
<p><strong>Headers Exchange</strong></p>
<p>Headers 也是根据规则匹配，相较于 Direct 和 Topic 固定地使用 routing_key，headers 则是一个自定义匹配规则的类型。</p>
<p>在队列与交换器绑定时，会设定一组键值对规则，消息中也包括一组键值对（headers 属性），当这些键值对有一对或全部匹配时，消息被投送到对应队列。</p>
<p><strong>Fanout Exchange</strong></p>
<p>Fanout Exchange 消息广播的模式，不管路由键或者是路由模式，<strong>会把消息发给绑定给它的全部队列</strong>，如果配置了 routing_key 会被忽略。</p>
<h3 id="Spring-Boot-集成-RabbitMQ"><a href="#Spring-Boot-集成-RabbitMQ" class="headerlink" title="Spring Boot 集成 RabbitMQ"></a>Spring Boot 集成 RabbitMQ</h3><p>Spring Boot 集成 RabbitMQ 非常简单，仅需非常少的配置就可使用，Spring Boot 提供了 spring-boot-starter-amqp 组件对 MQ 消息支持。</p>
<h4 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h4><p>（1）配置 pom 包，主要是添加 spring-boot-starter-amqp 的支持</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>（2）配置文件</p>
<p>配置 rabbitmq 的安装地址、端口以及账户信息：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.application.name</span>=<span class="string">Spring-boot-rabbitmq</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.0.1</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">admin</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">123456</span></span><br><span class="line"><span class="attr">复制</span></span><br></pre></td></tr></table></figure>

<p>（3）定义队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">Queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>（4）发送者</p>
<p>AmqpTemplate 是 Spring Boot 提供的默认实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloSender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;hello &quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender : &quot;</span> + context);</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;hello&quot;</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>（5）接收者</p>
<p>注意使用注解 @RabbitListener，使用 queues 指明队列名称，@RabbitHandler 为具体接收的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;hello&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String hello)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver  : &quot;</span> + hello);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>（6）测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@Spring</span> BootTest</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RabbitMqHelloTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloSender helloSender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        helloSender.send();</span><br><span class="line">        Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，发送者和接收者的 queue name 必须一致，不然不能接收。</p>
</blockquote>
<p>让测试方法等待一秒，让接收者接收到消息，不然应用退出时可能还没有接收到消息。</p>
<p>以上一个最常用简单的示例就完成了，下面我们介绍更复杂的使用场景。</p>
<h3 id="多方测试"><a href="#多方测试" class="headerlink" title="多方测试"></a>多方测试</h3><p>一个发送者和 N 个接收者或者 N 个发送者和 N 个接收者会出现什么情况呢？</p>
<h4 id="一对多发送"><a href="#一对多发送" class="headerlink" title="一对多发送"></a>一对多发送</h4><p>对上面的代码进行了小改造，接收端注册了两个 Receiver，Receiver1 和 Receiver2，发送端加入参数计数，接收端打印接收到的参数，下面是测试代码，发送一百条消息，来观察两个接收端的执行效果。</p>
<p>发送者示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NeoSender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;Spring boot neo queue&quot;</span>+<span class="string">&quot; ****** &quot;</span>+i;</span><br><span class="line">        System.out.println(<span class="string">&quot;Sender1 : &quot;</span> + context);</span><br><span class="line">        <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;neo&quot;</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>接收者 1 示例，接收者 2 和 1基本一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;neo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NeoReceiver1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String neo)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Receiver 1: &quot;</span> + neo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>我们设计了一个发送者，两个接收者，发送一百个消息看看效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oneToMany</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000l</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Receiver 2: Spring boot neo queue ****** 1</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 0</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 2</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 3</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 4</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 5</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 7</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 6</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 8</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 9</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 11</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 10</span><br><span class="line">...</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>根据返回结果得到以下结论：</p>
<blockquote>
<p>一个发送者，N 个接收者，经过测试接收端均匀接收到消息，也说明接收端自动进行了均衡负载，我们也可以利用这个特性做流量分发。</p>
</blockquote>
<h3 id="多对多发送"><a href="#多对多发送" class="headerlink" title="多对多发送"></a>多对多发送</h3><p>复用以上的发送者和接收者，再增加一个发送者 2 加入标记，在一百个循环中相互交替发送。</p>
<p>发送者方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;Spring boot neo queue&quot;</span>+<span class="string">&quot; ****** &quot;</span>+i;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sender2 : &quot;</span> + context);</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;neo&quot;</span>, context);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>两个发送者两个接收者的测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">manyToMany</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        neoSender.send(i);</span><br><span class="line">        neoSender2.send(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">10000l</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Sender1 : Spring boot neo queue ****** 0</span><br><span class="line">Sender2 : Spring boot neo queue ****** 0</span><br><span class="line">Sender1 : Spring boot neo queue ****** 1</span><br><span class="line">Sender2 : Spring boot neo queue ****** 1</span><br><span class="line">Sender1 : Spring boot neo queue ****** 2</span><br><span class="line">Sender2 : Spring boot neo queue ****** 2</span><br><span class="line">Sender1 : Spring boot neo queue ****** 3</span><br><span class="line">Sender2 : Spring boot neo queue ****** 3</span><br><span class="line">Sender1 : Spring boot neo queue ****** 4</span><br><span class="line">Sender2 : Spring boot neo queue ****** 4</span><br><span class="line">Sender1 : Spring boot neo queue ****** 5</span><br><span class="line">Sender2 : Spring boot neo queue ****** 5</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Receiver 2: Spring boot neo queue ****** 0</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 0</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 1</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 1</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 2</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 2</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 3</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 3</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 4</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 4</span><br><span class="line">Receiver 2: Spring boot neo queue ****** 5</span><br><span class="line">Receiver 1: Spring boot neo queue ****** 5</span><br><span class="line">...</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：发送端交替发送消息，接收端仍然会均匀接收到消息。</p>
</blockquote>
<h3 id="高级使用"><a href="#高级使用" class="headerlink" title="高级使用"></a>高级使用</h3><h4 id="对象的支持"><a href="#对象的支持" class="headerlink" title="对象的支持"></a>对象的支持</h4><p>Spring Boot 已经完美的支持对象的发送和接收，不需要格外的配置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sender object: &quot;</span> + user.toString());</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;object&quot;</span>, user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Receiver object : &quot;</span> + user);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>测试用例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendOject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;neo&quot;</span>);</span><br><span class="line">    user.setPass(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">    sender.send(user);</span><br><span class="line">    Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sender object: com.neo.model.User@66971f6b[name=neo,pass=123456]</span><br><span class="line">Receiver object : com.neo.model.User@14e38d67[name=neo,pass=123456]</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p><strong>Topic Exchange</strong></p>
<p>Topic 是 RabbitMQ 中最灵活的一种方式，可以根据 routing_key 自由的绑定不同的队列。</p>
<p>首先对 Topic 规则配置，这里使用两个队列来测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> <span class="string">&quot;topic.message&quot;</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">messages</span> <span class="operator">=</span> <span class="string">&quot;topic.messages&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(TopicRabbitConfig.message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queueMessages</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(TopicRabbitConfig.messages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    TopicExchange <span class="title function_">exchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(<span class="string">&quot;exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将队列和交换机绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeMessage</span><span class="params">(Queue queueMessage, TopicExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessage).to(exchange).with(<span class="string">&quot;topic.message&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeMessages</span><span class="params">(Queue queueMessages, TopicExchange exchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueMessages).to(exchange).with(<span class="string">&quot;topic.#&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>设计 queueMessages 同时匹配两个队列，queueMessage 只匹配“topic.message”队列。</p>
<p>发送者代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;hi, i am message 1&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sender : &quot;</span> + context);</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;topic.message&quot;</span>, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;hi, i am messages 2&quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sender : &quot;</span> + context);</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;exchange&quot;</span>, <span class="string">&quot;topic.messages&quot;</span>, context);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>接收者1代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;topic.message&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopicReceiver</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Topic Receiver1  : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>接收者 2 和 1 类似。</p>
<p>发送 send1 会匹配到 topic.# 和 topic.message 两个 Receiver 都可以收到消息；发送 send2 只有 topic.# 可以匹配，Receiver2 监听到了消息。</p>
<p>首先测试发送 send1()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topic1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    sender.send1();</span><br><span class="line">    Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>返回结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, i am message 1</span><br><span class="line">Topic Receiver1  : hi, i am message 1</span><br><span class="line">Topic Receiver2  : hi, i am message 1</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>说明两个接收者都接收到了消息。</p>
<p>再测试发送send2()：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">topic2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    sender.send2();</span><br><span class="line">    Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>返回结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, i am messages 2</span><br><span class="line">Topic Receiver2  : hi, i am messages 2</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>只有接收者2接收到了消息。两个方法都满足我们的预期，验证了我们的设想。</p>
<p><strong>Fanout Exchange</strong></p>
<p>Fanout 就是我们熟悉的广播模式或者订阅模式，给 Fanout 交换机发送消息，绑定了这个交换机的所有队列都收到这个消息。</p>
<p>Fanout 相关配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutRabbitConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义队列</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">AMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">BMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">CMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(<span class="string">&quot;fanout.C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义交换机</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    FanoutExchange <span class="title function_">fanoutExchange</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FanoutExchange</span>(<span class="string">&quot;fanoutExchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分部进行绑定</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeA</span><span class="params">(Queue AMessage,FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(AMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeB</span><span class="params">(Queue BMessage, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(BMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Binding <span class="title function_">bindingExchangeC</span><span class="params">(Queue CMessage, FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(CMessage).to(fanoutExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>这里使用了 A、B、C 三个队列绑定到 Fanout 交换机上面，发送端的 routing_key 写任何字符都会被忽略：</p>
<p>发生者如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">context</span> <span class="operator">=</span> <span class="string">&quot;hi, fanout msg &quot;</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Sender : &quot;</span> + context);</span><br><span class="line">    <span class="built_in">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;fanoutExchange&quot;</span>,<span class="string">&quot;&quot;</span>, context);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>接收者 A 代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;fanout.A&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FanoutReceiverA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fanout Receiver A: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>接收者 B、C 和接收者 A 类似，相见示例代码。</p>
<p>写测试用例调用 send() 进行测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fanoutSender</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    sender.send();</span><br><span class="line">    Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sender : hi, fanout msg </span><br><span class="line">fanout Receiver B: hi, fanout msg </span><br><span class="line">fanout Receiver C: hi, fanout msg </span><br><span class="line">fanout Receiver A: hi, fanout msg </span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>结果说明，绑定到 fanout 交换机上面的队列都收到了消息。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>RabbitMQ 一个非常高效的消息队列组件，使用 RabbitMQ 可以方便的解耦项目之间的依赖，同时利用 RabbitMQ 的特性可以做很多的解决方案。Spring Boot 为 RabbitMQ 提供了支持组件 spring-boot-starter-amqp，加载的时候会自动进行配置，并且预置了 RabbitTemplate，可以让我们在项目中方便的调用。在测试使用的过程中发现，RabbitMQ 非常的灵活，可以使用各种策略将不同的发送者和接收者绑定在一起，这些特性在实际项目使用中非常的高效便利。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2022/05/26/Spring%20Boot%20RabbitMQ/" data-id="clkwhj3u200126s7sem1507rr" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/05/17/Java-Stage3-Step3.3-Redis/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Tukeke<br>
      Theme <a href="https://github.com/Tukekehaohaonuli/" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>