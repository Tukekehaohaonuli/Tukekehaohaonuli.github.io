<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tukekenulia♥</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习使用缓存中间件Memcache">
<meta property="og:type" content="article">
<meta property="og:title" content="Tukekenulia♥">
<meta property="og:url" content="http://yoursite.com/2020/09/27/Spring%20Boot%20Memcache/index.html">
<meta property="og:site_name" content="Tukekenulia♥">
<meta property="og:description" content="学习使用缓存中间件Memcache">
<meta property="og:locale">
<meta property="article:published_time" content="2020-09-27T06:57:38.000Z">
<meta property="article:modified_time" content="2020-09-27T06:57:38.000Z">
<meta property="article:author" content="Tukeke">
<meta name="twitter:card" content="summary">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">Tukekenulia♥</div>
      
        <div id="subtitle">Stay focus,stay humble,stay curiosity.</div>
      
       <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/Tukekehaohaonuli" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="YOUR WEIBO HOME PAGE URL" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">Tukekenulia♥</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="yoursite.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring Boot Memcache" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/27/Spring%20Boot%20Memcache/" class="article-date">
  <time datetime="2020-09-27T06:57:38.000Z" itemprop="datePublished">2020-09-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习使用缓存中间件Memcache</p>
<span id="more"></span>

<h2 id="Spring-Boot-操作-Memcache"><a href="#Spring-Boot-操作-Memcache" class="headerlink" title="Spring Boot 操作 Memcache"></a>Spring Boot 操作 Memcache</h2><h3 id="Memcache-介绍"><a href="#Memcache-介绍" class="headerlink" title="Memcache 介绍"></a>Memcache 介绍</h3><p>Memcache 是一个自由和开放源代码、高性能、分配的内存对象缓存系统。Memcache 是一个高性能的分布式内存对象的 key-value 缓存系统，用于加速动态 Web 应用程序，减轻数据库负载，现在也有很多人将它作为内存式数据库在使用。它可以应对任意多个连接，使用非阻塞的网络 IO，由于它的工作机制是在内存中开辟一块空间，然后建立一个 Hash 表，Memcached 自动管理这些 Hash 表。</p>
<h4 id="Memcache-特点"><a href="#Memcache-特点" class="headerlink" title="Memcache 特点"></a>Memcache 特点</h4><p><strong>协议简单</strong></p>
<p>Memcache 的服务端客户端通信使用简单的文本协议，通过 Telnet 即可在 Memcached 上存取数据。</p>
<p><strong>基于 Libevent 的事件处理</strong></p>
<p>Libevent 是一套跨平台的事件处理接口的封装，能够兼容包括这些操作系统：Windows&#x2F;Linux&#x2F;BSD&#x2F;Solaris 等操作系统的的事件处理，包装的接口包括：poll、select（Windows）、epoll（Linux）、kqueue（BSD）&#x2F;dev&#x2F;pool（Solaris）。</p>
<p>Memcache 使用 Libevent 来进行网络并发连接的处理，能够保持在很大并发情况下，仍旧能够保持快速的响应能力。</p>
<p><strong>内置内存存储方式</strong></p>
<p>Memcache 中保存的数据都存储在 Memcache 内置的内存存储空间中。由于数据仅存在于内存中，因此重启 Memcache、重启操作系统会导致数据全部丢失。Memcache LRU（Least Recently Used）算法自动删除不使用的缓存，不过这个功能是可以配置的，Memcache 启动时通过“-M”参数可以禁止 LRU。不过，Memcache 本身是为缓存而设计的，建议开启 LRU。</p>
<p><strong>不适应场景</strong></p>
<ul>
<li>缓存对象不能大于 1 MB</li>
<li>key 的长度大于 250 字符</li>
<li>Memcache 未提供任何安全策略</li>
<li>不支持持久化</li>
</ul>
<h4 id="Memcache-安装"><a href="#Memcache-安装" class="headerlink" title="Memcache 安装"></a>Memcache 安装</h4><p>在 Centos 下安装使用 yum 命令安装 Memcache 非常简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y memcached</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>启动：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/memcached -b  -p 11211 -m 150 -u root &gt;&gt; /tmp/memcached.log  &amp;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>启动参数可以配置，常用的命令选项如下：</p>
<ul>
<li>m 内存</li>
<li>c 最大链接数</li>
<li>p 端口</li>
<li>u 用户</li>
<li>t 线程数</li>
</ul>
<p>查看 memcached 是否在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep memcached</span><br></pre></td></tr></table></figure>

<h3 id="Memcache-客户端"><a href="#Memcache-客户端" class="headerlink" title="Memcache 客户端"></a>Memcache 客户端</h3><p>Memcached Client 目前有 3 种：</p>
<ul>
<li>Memcached Client for Java（已经停止更新）</li>
<li>SpyMemcached（已经停止更新）</li>
<li>XMemcached（主流使用）</li>
</ul>
<p>Memcached Client for Java 比 SpyMemcached 更稳定、更早、更广泛；SpyMemcached 比 Memcached Client for Java 更高效；XMemcached 比 SpyMemcache 并发效果更好。</p>
<p><strong>Spymemcached 介绍</strong></p>
<p>Spymemcached 是一个采用 Java 开发的异步、单线程的 Memcached 客户端，使用 NIO 实现。Spymemcached 是 Memcached 的一个流行的 Java Client 库，性能表现出色，广泛应用于 Java + Memcached 项目中。</p>
<p><strong>XMemcached 简介</strong></p>
<p>现在使用最广泛的 Memcache Java 客户端是 XMemcached，它是一个新的 Java Memcache Client 。Memcached 通过它的自定义协议与客户端交互，而 XMemcached 就是它的一个 Java 客户端实现。</p>
<p><strong>XMemcached 的主要特性</strong></p>
<p>XMemcached 支持设置连接池、宕机报警、使用二进制文件、一致性哈希算法、进行数据压缩等操作，总结如下：</p>
<ul>
<li>高性能，由 Nio 支持；</li>
<li>协议完整，Xmemcached 支持所有的 Memcached 协议，包括 1.4.0 正式开始使用的二进制协议；</li>
<li>支持客户端分布，提供了一致性哈希（Consistent Hash）算法的实现；</li>
<li>允许设置节点权重，XMemcached 允许通过设置节点的权重来调节 Memcached 的负载，设置的权重越高，该 Memcached 节点存储的数据将越多，所承受的负载越大；</li>
<li>动态增删节点，Memcached 允许通过 JMX 或者代码编程实现节点的动态添加或者移除，方便用户扩展和替换节点等；</li>
<li>XMemcached 通过 JMX 暴露的一些接口，支持 Client 本身的监控和调整，允许动态设置调优参数、查看统计数据、动态增删节点等；</li>
<li>支持客户端连接池，对同一个 Memcached 可以创建 N 个连接组成连接池来提高客户端在高并发环境下的表现，而这一切对使用者来说却是透明的；</li>
<li>可扩展性，XMemcached 是基于 Java Nio 框架 Yanf4j 实现的，因此在实现上结构相对清楚，分层比较明晰。</li>
</ul>
<h3 id="Spring-Boot-使用-Xmemcached-集成-Memcache。"><a href="#Spring-Boot-使用-Xmemcached-集成-Memcache。" class="headerlink" title="Spring Boot 使用 Xmemcached 集成 Memcache。"></a>Spring Boot 使用 Xmemcached 集成 Memcache。</h3><h4 id="添加配置"><a href="#添加配置" class="headerlink" title="添加配置"></a>添加配置</h4><p>添加依赖包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.googlecode.xmemcached<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmemcached<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 单个 Memcached 配置</span><br><span class="line">memcached.servers=192.168.0.161:11211</span><br><span class="line"># 连接池</span><br><span class="line">memcached.poolSize=10</span><br><span class="line">#操作超时时间</span><br><span class="line">memcached.opTimeout=6000</span><br></pre></td></tr></table></figure>

<p>当配置文件完成之后出现：Spring Boot Configuration Annotation Processor not configured</p>
<p>则添加依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>添加配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 单个 Memcached 配置</span><br><span class="line">memcached.servers=192.168.0.161:11211</span><br><span class="line"># 连接池</span><br><span class="line">memcached.poolSize=10</span><br><span class="line">#操作超时时间</span><br><span class="line">memcached.opTimeout=6000</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>配置 Memcached 的地址和端口号、连接池和操作超时时间，使用集群时可以拼接多个地址：**”host1:port1 host2:port2 …”**。</p>
<p>创建 XMemcachedProperties 类，读配置信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;memcached&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XMemcachedProperties</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String servers;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> opTimeout;</span><br><span class="line">    <span class="comment">//省略 getter/setter</span></span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<h4 id="启动加载"><a href="#启动加载" class="headerlink" title="启动加载"></a>启动加载</h4><p>利用 @Configuration 注解，在启动时对 Memcached 进行初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemcachedBuilder</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span>  LoggerFactory.getLogger(MemcachedBuilder.class);</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> XMemcachedProperties xMemcachedProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span>  MemcachedClient <span class="title function_">getMemcachedClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MemcachedClient</span> <span class="variable">memcachedClient</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MemcachedClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMemcachedClientBuilder</span>(AddrUtil.getAddresses(xMemcachedProperties.getServers()));</span><br><span class="line">            builder.setConnectionPoolSize(xMemcachedProperties.getPoolSize());</span><br><span class="line">            builder.setOpTimeout(xMemcachedProperties.getOpTimeout());</span><br><span class="line">            memcachedClient = builder.build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;inint MemcachedClient failed &quot;</span>,e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memcachedClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 XMemcachedClient 的创建有比较多的可选项，所以提供了一个 XMemcachedClientBuilder 类用于构建 MemcachedClient。MemcachedClient 是主要接口，操作 Memcached 的主要方法都在这个接口，XMemcachedClient 是它的一个实现。</p>
<p>在方法 getMemcachedClient() 添加 @Bean 注解，代表启动时候将方法构建好的实例注入到 Spring 容器中，后面在需要使用的类中，直接注入 MemcachedClient 即可。</p>
<h4 id="进行测试"><a href="#进行测试" class="headerlink" title="进行测试"></a>进行测试</h4><p>我们创建一个 MemcachedTests 类，来测试 Memcached 配置信息是否配置正确。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemcachedTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MemcachedClient memcachedClient;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>测试 Memcached 的 get 、set 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    memcachedClient.set(<span class="string">&quot;hello&quot;</span>, <span class="number">0</span>, <span class="string">&quot;Hello,xmemcached&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> memcachedClient.get(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;hello=&quot;</span> + value);</span><br><span class="line">    memcachedClient.delete(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存储数据是通过 set 方法，它有三个参数，第一个是存储的 key 名称，第二个是 expire 时间（单位秒），超过这个时间，memcached 将这个数据替换出去，0 表示永久存储（默认是一个月），第三个参数就是实际存储的数据，可以是任意的 Java 可序列化类型。</p>
<p>获取存储的数据是通过 get 方法，传入 key 名称即可；如果要删除存储的数据，可以通过 delete 方法，它也是接受 key 名称作为参数。</p>
<p>执行 testMemcached() 单元测试之后，控制台会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello=Hello,xmemcached</span><br></pre></td></tr></table></figure>

<p>证明 Memcached 配置、设置和获取值成功。</p>
<h3 id="XMemcached-语法介绍"><a href="#XMemcached-语法介绍" class="headerlink" title="XMemcached 语法介绍"></a>XMemcached 语法介绍</h3><p>XMemcached 有非常丰富的语法来支持，我们对缓存使用的各种场景，接下来一一介绍。</p>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><p>除过上面的 get、set、delete 等方法外，Memcache 还有很多常用的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMore</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (!memcachedClient.set(<span class="string">&quot;hello&quot;</span>, <span class="number">0</span>, <span class="string">&quot;world&quot;</span>)) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;set error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!memcachedClient.add(<span class="string">&quot;hello&quot;</span>, <span class="number">0</span>, <span class="string">&quot;dennis&quot;</span>)) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Add error,key is existed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!memcachedClient.replace(<span class="string">&quot;hello&quot;</span>, <span class="number">0</span>, <span class="string">&quot;dennis&quot;</span>)) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;replace error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    memcachedClient.append(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot; good&quot;</span>);</span><br><span class="line">    memcachedClient.prepend(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> memcachedClient.get(<span class="string">&quot;hello&quot;</span>, <span class="keyword">new</span> <span class="title class_">StringTranscoder</span>());</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    memcachedClient.deleteWithNoReply(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<ul>
<li>add 命令，用于将 value（数据值）存储在指定的 key（键）中。如果 add 的 key 已经存在，则不会更新数据（过期的 key 会更新），之前的值将仍然保持相同，并且将获得响应 NOT_STORED。</li>
<li>replace 命令，用于替换已存在的 key（键）的 value（数据值）。如果 key 不存在，则替换失败，并且将获得响应 NOT_STORED。</li>
<li>append 命令，用于向已存在 key（键）的 value（数据值）后面追加数据。</li>
<li>prepend 命令，用于向已存在 key（键）的 value（数据值）前面追加数据。</li>
<li>deleteWithNoReply 方法，这个方法删除数据并且告诉 Memcached，不用返回应答，因此这个方法不会等待应答直接返回，比较适合于批量处理。</li>
</ul>
<h4 id="Incr-和-Decr"><a href="#Incr-和-Decr" class="headerlink" title="Incr 和 Decr"></a>Incr 和 Decr</h4><p>Incr 和 Decr 类似数据的增和减，两个操作类似 Java 中的原子类如 AtomicIntger，用于原子递增或者递减变量数值，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testIncrDecr</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    memcachedClient.delete(<span class="string">&quot;Incr&quot;</span>);</span><br><span class="line">    memcachedClient.delete(<span class="string">&quot;Decr&quot;</span>);</span><br><span class="line">    System.out.println(memcachedClient.incr(<span class="string">&quot;Incr&quot;</span>, <span class="number">6</span>, <span class="number">12</span>));</span><br><span class="line">    System.out.println(memcachedClient.incr(<span class="string">&quot;Incr&quot;</span>, <span class="number">3</span>));</span><br><span class="line">    System.out.println(memcachedClient.incr(<span class="string">&quot;Incr&quot;</span>, <span class="number">2</span>));</span><br><span class="line">    System.out.println(memcachedClient.decr(<span class="string">&quot;Decr&quot;</span>, <span class="number">1</span>, <span class="number">6</span>));</span><br><span class="line">    System.out.println(memcachedClient.decr(<span class="string">&quot;Decr&quot;</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>为了防止数据干扰，在测试开始前前调用 delete() 方法清除两个 key 值。</p>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">15</span><br><span class="line">17</span><br><span class="line">6</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>Incr 和 Decr 都有三个参数的方法，第一个参数指定递增的 key 名称，第二个参数指定递增的幅度大小，第三个参数指定当 key 不存在的情况下的初始值，两个参数的重载方法省略了第三个参数，默认指定为 0。</p>
<h4 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h4><p>Xmemcached 还提供了一个称为计数器的封装，它封装了 incr&#x2F;decr 方法，使用它就可以类似 AtomicLong 那样去操作计数，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCounter</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">MemcachedClient</span> <span class="variable">memcachedClient</span> <span class="operator">=</span> memcachedUtil.getMemcachedClient();</span><br><span class="line">    Counter counter=memcachedClient.getCounter(<span class="string">&quot;counter&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;counter=&quot;</span>+counter.get());</span><br><span class="line">    <span class="type">long</span> <span class="variable">c1</span> <span class="operator">=</span>counter.incrementAndGet();</span><br><span class="line">    System.out.println(<span class="string">&quot;counter=&quot;</span>+c1);</span><br><span class="line">    <span class="type">long</span> <span class="variable">c2</span> <span class="operator">=</span>counter.decrementAndGet();</span><br><span class="line">    System.out.println(<span class="string">&quot;counter=&quot;</span>+c2);</span><br><span class="line">    <span class="type">long</span> <span class="variable">c3</span> <span class="operator">=</span>counter.addAndGet(-<span class="number">10</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;counter=&quot;</span>+c3);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<ul>
<li><code>memcachedClient.getCounter(&quot;counter&quot;,10)</code>，第一个参数为计数器的 key，第二参数当 key 不存在时的默认值；</li>
<li><code>counter.incrementAndGet()</code>，执行一次给计数器加 1；</li>
<li><code>counter.decrementAndGet()</code>，执行一次给计数器减 1。</li>
</ul>
<p>查看 counter.addAndGet(-10) 源码（如下），发现 addAndGet() 会根据传入的值的正负来判断，选择直接给对应的 key 加多少或者减多少，底层也是使用了 incr() 和 decr() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">long</span> delta)</span> <span class="keyword">throws</span> MemcachedException, InterruptedException, TimeoutException &#123;</span><br><span class="line">    <span class="keyword">return</span> delta &gt;= <span class="number">0L</span> ? <span class="built_in">this</span>.memcachedClient.incr(<span class="built_in">this</span>.key, delta, <span class="built_in">this</span>.initialValue) : <span class="built_in">this</span>.memcachedClient.decr(<span class="built_in">this</span>.key, -delta, <span class="built_in">this</span>.initialValue);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>Counter 适合在高并发抢购场景下做并发控制。</p>
<h4 id="CAS-操作"><a href="#CAS-操作" class="headerlink" title="CAS 操作"></a>CAS 操作</h4><p>Memcached 是通过 CAS 协议实现原子更新，所谓原子更新就是 Compare and Set，原理类似乐观锁，每次请求存储某个数据同时要附带一个 CAS 值，Memcached 比对这个 CAS 值与当前存储数据的 CAS 值是否相等，如果相等就让新的数据覆盖老的数据，如果不相等就认为更新失败，这在并发环境下特别有用。XMemcached 提供了对 CAS 协议的支持（无论是文本协议还是二进制协议），CAS 协议其实是分为两个步骤：获取 CAS 值和尝试更新，因此一个典型的使用场景如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GetsResponse&lt;Integer&gt; result = client.gets(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="type">long</span> <span class="variable">cas</span> <span class="operator">=</span> result.getCas(); </span><br><span class="line"><span class="comment">//尝试将 a 的值更新为 2</span></span><br><span class="line"><span class="keyword">if</span> (!client.cas(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="number">2</span>, cas)) &#123;</span><br><span class="line">    System.err.println(<span class="string">&quot;cas error&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>首先通过 gets 方法获取一个 GetsResponse，此对象包装了存储的数据和 CAS 值，然后通过 CAS 方法尝试原子更新，如果失败打印“cas error”。显然，这样的方式很繁琐，并且如果你想尝试多少次原子更新就需要一个循环来包装这一段代码，因此 XMemcached 提供了一个 <em>CASOperation</em> 接口包装了这部分操作，允许你尝试 N 次去原子更新某个 key 存储的数据，无需显式地调用 gets 获取 CAS 值，上面的代码简化为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">client.cas(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>, <span class="keyword">new</span> <span class="title class_">CASOperation</span>&lt;Integer&gt;() &#123;</span><br><span class="line">             <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMaxTries</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">getNewValue</span><span class="params">(<span class="type">long</span> currentCAS, Integer currentValue)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>CASOpertion 接口只有两个方法，一个是设置最大尝试次数的 getMaxTries 方法，这里是尝试一次，如果尝试超过这个次数没有更新成功将抛出一个 TimeoutException，如果你想无限尝试（理论上），可以将返回值设定为 Integer.MAX_VALUE；另一个方法是根据当前获得的 GetsResponse 来决定更新数据的 getNewValue 方法，如果更新成功，这个方法返回的值将存储成功，其两个参数是最新一次 gets 返回的 GetsResponse 结果。</p>
<h4 id="设置超时时间"><a href="#设置超时时间" class="headerlink" title="设置超时时间"></a>设置超时时间</h4><p>XMemcached 由于是基于 nio，因此通讯过程本身是异步的，client 发送一个请求给 Memcached，你是无法确定 Memcached 什么时候返回这个应答，客户端此时只有等待，因此还有个等待超时的概念在这里。客户端在发送请求后，开始等待应答，如果超过一定时间就认为操作失败，这个等待时间默认是 5 秒，也可以在获取的时候配置超时时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value=client.get(<span class="string">&quot;hello&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>就是等待 3 秒超时，如果 3 秒超时就跑出 TimeutException，用户需要自己处理这个异常。因为等待是通过调用 CountDownLatch.await(timeout) 方法，所以用户还需要处理中断异常 InterruptException，最后的 MemcachedException 表示 Xmemcached 内部发生的异常，如解码编码错误、网络断开等异常情况。</p>
<h4 id="更新缓存过期时间"><a href="#更新缓存过期时间" class="headerlink" title="更新缓存过期时间"></a>更新缓存过期时间</h4><p>经常有这样的需求，就是希望更新缓存数据的超时时间（expire time），现在 Memcached 已经支持 touch 协议，只需要传递 key 就更新缓存的超时时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.touch(key,<span class="keyword">new</span>-expire-time);</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>有时候你希望获取缓存数据并更新超时时间，这时候可以用 getAndTouch 方法（仅二进制协议支持）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client.getAndTouch(key,<span class="keyword">new</span>-expire-time);</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>如果在使用过程中报以下错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: net.rubyeye.xmemcached.exception.UnknownCommandException: Response error,error message:Unknow command TOUCH,key=Touch</span><br><span class="line">    at net.rubyeye.xmemcached.command.Command.decodeError(Command.java:250)</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>说明安装的 Memcached 服务不支持 touch 命令，建议升级。</p>
<p>测试示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTouch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    memcachedClient.set(<span class="string">&quot;Touch&quot;</span>, <span class="number">2</span>, <span class="string">&quot;Touch Value&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    memcachedClient.touch(<span class="string">&quot;Touch&quot;</span>,<span class="number">6</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span>memcachedClient.get(<span class="string">&quot;Touch&quot;</span>,<span class="number">3000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Touch=&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Memcached-集群"><a href="#Memcached-集群" class="headerlink" title="Memcached 集群"></a>Memcached 集群</h4><p>Memcached 的分布是通过客户端实现的，客户端根据 key 的哈希值得到将要存储的 Memcached 节点，并将对应的 value 存储到相应的节点。</p>
<p>XMemcached 同样支持客户端的分布策略，默认分布的策略是按照 key 的哈希值模以连接数得到的余数，对应的连接就是将要存储的节点。如果使用默认的分布策略，不需要做任何配置或者编程。</p>
<p>XMemcached 同样支持<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Consistent_hashing">一致性哈希</a>（Consistent Hash)，通过编程设置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MemcachedClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMemcachedClientBuilder</span>(AddrUtil.getAddresses(<span class="string">&quot;server1:11211 server2:11211 server3:11211&quot;</span>));</span><br><span class="line">builder.setSessionLocator(<span class="keyword">new</span> <span class="title class_">KetamaMemcachedSessionLocator</span>());</span><br><span class="line">MemcachedClient client=builder.build();</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>XMemcached 还提供了额外的一种哈希算法——选举散列，在某些场景下可以替代一致性哈希：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MemcachedClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMemcachedClientBuilder</span>(</span><br><span class="line">                                    AddrUtil.getAddresses(<span class="string">&quot;server1:11211 server2:11211 server3:11211&quot;</span>));</span><br><span class="line">builder.setSessionLocator(<span class="keyword">new</span> <span class="title class_">ElectionMemcachedSessionLocator</span>());</span><br><span class="line"><span class="type">MemcachedClient</span> <span class="variable">mc</span> <span class="operator">=</span> builder.build();</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>在集群的状态下可以给每个服务设置不同的权重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MemcachedClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMemcachedClientBuilder</span>(AddrUtil.getAddresses(<span class="string">&quot;localhost:12000 localhost:12001&quot;</span>),<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;);</span><br><span class="line">MemcachedClient memcachedClient=builder.build();</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p><strong>SASL 验证</strong></p>
<p>Memcached 1.4.3 开始支持 SASL 验证客户端，在服务器配置启用 SASL 之后，客户端需要通过授权验证才可以跟 Memcached 继续交互，否则将被拒绝请求，XMemcached 1.2.5 开始支持这个特性。假设 Memcached 设置了 SASL 验证，典型地使用 CRAM-MD 5 或者 PLAIN 的文本用户名和密码的验证机制，假设用户名为 cacheuser，密码为 123456，那么编程的方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MemcachedClientBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMemcachedClientBuilder</span>(</span><br><span class="line">                AddrUtil.getAddresses(<span class="string">&quot;localhost:11211&quot;</span>));</span><br><span class="line">builder.addAuthInfo(AddrUtil.getOneAddress(<span class="string">&quot;localhost:11211&quot;</span>), AuthInfo</span><br><span class="line">                .typical(<span class="string">&quot;cacheuser&quot;</span>, <span class="string">&quot;123456&quot;</span>));</span><br><span class="line"><span class="comment">// Must use binary protocol</span></span><br><span class="line">builder.setCommandFactory(<span class="keyword">new</span> <span class="title class_">BinaryCommandFactory</span>());</span><br><span class="line">MemcachedClient client=builder.build();</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>请注意，授权验证仅支持二进制协议。</p>
<h4 id="查看统计信息"><a href="#查看统计信息" class="headerlink" title="查看统计信息"></a>查看统计信息</h4><p>Memcached 提供了统计协议用于查看统计信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;InetSocketAddress,Map&lt;String,String&gt;&gt; result=client.getStats();</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>getStats 方法返回一个 map ，其中存储了所有已经连接并且有效的 Memcached 节点返回的统计信息，你也可以统计具体的项目，如统计 items 项目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;InetSocketAddress,Map&lt;String,String&gt;&gt; result=client.getStatsByItem(&quot;items&quot;);</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>只要向 getStatsByItem 传入需要统计的项目名称即可，我们可以利用这个功能，来做 Memcached 状态监控等。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Memcached 是一款非常流行的缓存中间件，被广泛应用在各场景中，使用缓存可以缓解数据库压力，某些场景下使用缓存可以大大提高复用的 Tps 。 XMemcached 是 Memcached 的一个高性能 Nio 客户端，支持 Memcached 底层各种操作，并且在 Memcached 协议的基础上进行了封装和完善，提供了连接池、集群、数据压缩、分布式算法等高级功能，不论是完善度和性能各方面来看，XMemcached 都是目前最为推荐的一款 Memcached 客户端。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2020/09/27/Spring%20Boot%20Memcache/" data-id="clkwhj3u1000y6s7sgmsoc41j" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/28/Spring%20Boot%20Cache/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2020/09/26/Spring%20Data%20JPA%20%E5%92%8C%20Thymeleaf%20%E7%BB%BC%E5%90%88%E5%AE%9E%E8%B7%B5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Tukeke<br>
      Theme <a href="https://github.com/Tukekehaohaonuli/" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>