<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Tukekenulia</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习使用消息队列中间件ActiveMQ。">
<meta property="og:type" content="article">
<meta property="og:title" content="Tukekenulia">
<meta property="og:url" content="http://yoursite.com/2020/09/28/Spring%20Boot%20ActiveMQ/index.html">
<meta property="og:site_name" content="Tukekenulia">
<meta property="og:description" content="学习使用消息队列中间件ActiveMQ。">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/Spring-Boot-ActiveMQ/1.png">
<meta property="article:published_time" content="2020-09-28T13:23:42.000Z">
<meta property="article:modified_time" content="2020-09-28T13:23:42.000Z">
<meta property="article:author" content="Tukeke">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/Spring-Boot-ActiveMQ/1.png">
  
  
    <link rel="icon" href="/11.png">
  
  <link type="text/css" href="//netdna.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/css/scrollUp/image.css">

  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <div class="logo">
        <img src="/logo.png" alt="Profile Picture">
      </div>
      <div id="title">Tukekenulia</div>
      
        <div id="subtitle">Stay focus,stay humble,stay curiosity.</div>
      
       <ul class="my-socials">
  
  <li>
  	<a href="https://github.com/Tukekehaohaonuli" class="github" target="_blank">
  		<i class="fa fa-github"></i>
  	</a>
  </li>
  
  <li>
  	<a href="YOUR WEIBO HOME PAGE URL" class="weibo" target="_blank">
  		<i class="fa fa-weibo"></i>
  	</a>
  </li>
  
 
</ul>
    </div>
  </div>
  <div id="header-inner" class="">
    <nav id="main-nav">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <!--
        
          
            <a class="main-nav-link" href="/">首页</a>
          
            <a class="main-nav-link" href="/categories/life">生活</a>
          
            <a class="main-nav-link" href="/archives">归档</a>
          
        
      -->
    </nav>
    <nav id="title-nav" style="display:none">
      <a href="/">Tukekenulia</a>
      <img src="/logo.png" alt="Profile Picture">
      <!--
      <span id="title-nav-socials">
        
       
     </span>
      -->
    </nav>
    <nav id="sub-nav">
      
      <a id="nav-search-btn" class="nav-icon" title="Search"></a>
    </nav>
    <div id="search-form-wrap">
      <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
        <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
        <input type="submit" value="" class="search-form-submit">
        <input name=tn type=hidden value="bds">
        <input name=cl type=hidden value="3">
        <input name=ct type=hidden value="2097152">
        <input type="hidden" name="si" value="yoursite.com">
      </form>
    </div>
  </div>
  <div class="site-nav" style="display: none;">
    <ul>
      
      
        <li><a href="/">首页</a></li>
      
        <li><a href="/categories/life">生活</a></li>
      
        <li><a href="/archives">归档</a></li>
      
      
    </ul>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Spring Boot ActiveMQ" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/28/Spring%20Boot%20ActiveMQ/" class="article-date">
  <time datetime="2020-09-28T13:23:42.000Z" itemprop="datePublished">2020-09-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习使用消息队列中间件ActiveMQ。</p>
<span id="more"></span>

<h1 id="1-ActiveMQ的安装与使用"><a href="#1-ActiveMQ的安装与使用" class="headerlink" title="1-ActiveMQ的安装与使用"></a>1-ActiveMQ的安装与使用</h1><p>ActiveMQ下载地址：<a target="_blank" rel="noopener" href="http://activemq.apache.org/activemq-5158-release.html">http://activemq.apache.org/activemq-5158-release.html</a></p>
<p>1、gz文件拷贝到&#x2F;usr&#x2F;local&#x2F;src目录</p>
<p>2、解压</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-activemq-5.15.8-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd apache-activemq-5.15.8</span><br><span class="line">cd bin</span><br><span class="line">./activemq start</span><br><span class="line"></span><br><span class="line">关闭 ./activemq stop</span><br></pre></td></tr></table></figure>



<p>4、查看端口状态</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anp|grep 61616</span><br></pre></td></tr></table></figure>

<p>修改防火墙之后：</p>
<p><img src="/images/Spring-Boot-ActiveMQ/1.png" alt="1"></p>
<p>ActiveMQ可以新增账号密码</p>
<h1 id="2-使用-Spring-Boot-操作-ActiveMQ"><a href="#2-使用-Spring-Boot-操作-ActiveMQ" class="headerlink" title="2-使用 Spring Boot 操作 ActiveMQ"></a>2-使用 Spring Boot 操作 ActiveMQ</h1><p>消息队列中间件是分布式系统中重要的组件，主要解决应用耦合、异步消息、流量削锋等问题，实现高性能、高可用、可伸缩和最终一致性架构，是大型分布式系统不可缺少的中间件。</p>
<p>目前在生产环境中使用较多的消息队列有 ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ 等。</p>
<p><strong>特性</strong></p>
<ul>
<li>异步性：将耗时的同步操作通过以发送消息的方式进行了异步化处理，减少了同步等待的时间。</li>
<li>松耦合：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节，只要定义好消息的格式就行。</li>
<li>分布式：通过对消费者的横向扩展，降低了消息队列阻塞的风险，以及单个消费者产生单点故障的可能性（当然消息队列本身也可以做成分布式集群）。</li>
<li>可靠性：消息队列一般会把接收到的消息存储到本地硬盘上（当消息被处理完之后，存储信息根据不同的消息队列实现，有可能将其删除），这样即使应用挂掉或者消息队列本身挂掉，消息也能够重新加载。</li>
</ul>
<p><strong>JMS 规范</strong></p>
<p>JMS 即 Java 消息服务（Java Message Service）应用程序接口，是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的 API，绝大多数 MOM 提供商都对 JMS 提供支持。</p>
<p>JMS 的消息机制有 2 种模型，一种是 Point to Point，表现为队列的形式，发送的消息，只能被一个接收者取走；另一种是 Topic，可以被多个订阅者订阅，类似于群发。</p>
<p>ActiveMQ 是 JMS 的一个实现。</p>
<h3 id="ActiveMQ-介绍"><a href="#ActiveMQ-介绍" class="headerlink" title="ActiveMQ 介绍"></a>ActiveMQ 介绍</h3><p>ActiveMQ 是 Apache 软件基金下的一个开源软件，它遵循 JMS1.1 规范（Java Message Service），是消息驱动中间件软件（MOM）。它为企业消息传递提供高可用、出色性能、可扩展、稳定和安全保障。ActiveMQ 使用 Apache 许可协议，因此，任何人都可以使用和修改它而不必反馈任何改变。</p>
<p>ActiveMQ 的目标是在尽可能多的平台和语言上提供一个标准的，消息驱动的应用集成。ActiveMQ 实现 JMS 规范并在此之上提供大量额外的特性。ActiveMQ 支持队列和订阅两种模式的消息发送。</p>
<p>Spring Boot 提供了 ActiveMQ 组件 spring-boot-starter-activemq，用来支持 ActiveMQ 在 Spring Boot 体系内使用，下面我们来详细了解如何使用。</p>
<h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><p>主要添加组件：spring-boot-starter-activemq。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-activemq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>在 application.properties 中添加配置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于内存的 ActiveMQ</span></span><br><span class="line"><span class="attr">spring.activemq.in-memory</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 不适应连接池</span></span><br><span class="line"><span class="attr">spring.activemq.pool.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 独立安装的 ActiveMQ</span></span><br><span class="line"><span class="comment">#spring.activemq.broker-url=tcp://192.168.3.39:61616</span></span><br><span class="line"><span class="comment">#spring.activemq.user=admin</span></span><br><span class="line"><span class="comment">#spring.activemq.password=admin</span></span><br></pre></td></tr></table></figure>

<p>在使用 ActiveMQ 时有两种使用方式，一种是使用独立安装的 ActiveMQ，在生产环境推荐使用这种；另一种是使用基于内存 ActiveMQ ，在调试阶段建议使用这种方式。</p>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列发送的消息，只能被一个消费者接收。</p>
<h4 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">queue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveMQQueue</span>(<span class="string">&quot;neo.queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>使用 @Configuration 注解在项目启动时，定义了一个队列 queue 命名为：neo.queue。</p>
<h4 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h4><p>创建一个消息的生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendQueue</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send queue msg :&quot;</span>+msg);</span><br><span class="line">        <span class="built_in">this</span>.jmsMessagingTemplate.convertAndSend(<span class="built_in">this</span>.queue, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>JmsMessagingTemplate 是 Spring 提供发送消息的工具类，使用 JmsMessagingTemplate 和创建好的 queue 对消息进行发送。</p>
<h4 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;neo.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveQueue</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer queue msg : &quot;</span>+text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>使用注解 @JmsListener(destination &#x3D; “neo.queue”)，表示此方法监控了名为 neo.queue 的队列。当队列 neo.queue 中有消息发送时会触发此方法的执行，text 为消息内容。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>创建 SampleActiveMqTests 测试类，注入创建好的消息生产者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleActiveMqTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Producer producer;</span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">OutputCapture</span> <span class="variable">outputCapture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputCapture</span>();</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>OutputCapture 是 Spring Boot 提供的一个测试类，它能捕获 System.out 和 System.err 的输出，我们可以利用这个特性来判断程序中的输出是否执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleQueueMessage</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.producer.sendQueue(<span class="string">&quot;Test queue message&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">    assertThat(<span class="built_in">this</span>.outputCapture.toString().contains(<span class="string">&quot;Test queue&quot;</span>)).isTrue();</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>创建测试方式，使用 producer 发送消息，为了保证容器可以接收到消息，让测试方法等待 1 秒，最后使用 outputCapture 判断是否执行成功。</p>
<h4 id="测试多消费者"><a href="#测试多消费者" class="headerlink" title="测试多消费者"></a>测试多消费者</h4><p>上面的案例只是一个生产者一个消费者，我们在模拟一个生产者和多个消费者队列的执行情况。我们复制上面的消费者 Consumer 重新命名为 Consumer2，并且将输出内容加上 2 的关键字，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer2</span> &#123;</span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;neo.queue&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveQueue</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer2 queue msg : &quot;</span>+text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>在刚才的测试类中添加一个 send100QueueMessage() 方法，模式发送 100 条消息时，两个消费者是如何消费消息的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send100QueueMessage</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">this</span>.producer.sendQueue(<span class="string">&quot;Test queue message&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>控制台输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Consumer queue msg : Test queue message0</span><br><span class="line">Consumer2 queue msg : Test queue message1</span><br><span class="line">Consumer queue msg : Test queue message2</span><br><span class="line">Consumer2 queue msg : Test queue message3</span><br><span class="line">...</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>根据控制台输出的消息可以看出，当有多个消费者监听一个队列时，消费者会自动均衡负载的接收消息，并且每个消息只能有一个消费者所接收。</p>
<blockquote>
<p>注意：控制台输出 javax.jms.JMSException: peer (vm:&#x2F;&#x2F;localhost#1) stopped. 报错信息可以忽略，这是 Info 级别的错误，是 ActiveMQ 的一个 bug。</p>
</blockquote>
<h3 id="广播（Topic）"><a href="#广播（Topic）" class="headerlink" title="广播（Topic）"></a>广播（Topic）</h3><p>广播发送的消息，可以被多个消费者接收。</p>
<h4 id="创建-Topic"><a href="#创建-Topic" class="headerlink" title="创建 Topic"></a>创建 Topic</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Topic <span class="title function_">topic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ActiveMQTopic</span>(<span class="string">&quot;neo.topic&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>使用 @Configuration 注解在项目启动时，定义了一个广播 Topic 命名为：neo.topic。</p>
<h4 id="消息生产者-1"><a href="#消息生产者-1" class="headerlink" title="消息生产者"></a>消息生产者</h4><p>创建一个消息的生产者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Producer</span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JmsMessagingTemplate jmsMessagingTemplate;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Topic topic;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendTopic</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;send topic msg :&quot;</span>+msg);</span><br><span class="line">        <span class="built_in">this</span>.jmsMessagingTemplate.convertAndSend(<span class="built_in">this</span>.topic, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>和上面的生产者对比只是 convertAndSend() 方法传入的第一个参数变成了 Topic。</p>
<h4 id="消息消费者-1"><a href="#消息消费者-1" class="headerlink" title="消息消费者"></a>消息消费者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;neo.topic&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveTopic</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer topic msg : &quot;</span>+text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>消费者也没有变化，只是监听的名改为上面的 neo.topic，因为模拟多个消费者，复制一份 Consumer 命名为 Consumer2，代码相同在输出中标明来自 Consumer2。</p>
<h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><p>创建 SampleActiveMqTests 测试类，注入创建好的消息生产者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendSimpleTopicMessage</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="built_in">this</span>.producer.sendTopic(<span class="string">&quot;Test Topic message&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>测试方法执行成功后，会看到控制台输出信息，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">send topic msg :Test Topic message</span><br><span class="line">Consumer topic msg : Test Topic message</span><br><span class="line">Consumer2 topic msg : Test Topic message</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>可以看出两个消费者都收到了发送的消息，从而验证广播（Topic）是一个发送者多个消费者的模式。</p>
<h3 id="同时支持队列（Queue）和广播（Topic）"><a href="#同时支持队列（Queue）和广播（Topic）" class="headerlink" title="同时支持队列（Queue）和广播（Topic）"></a>同时支持队列（Queue）和广播（Topic）</h3><p>Spring Boot 集成 ActiveMQ 的项目默认只支持队列或者广播中的一种，通过配置项 spring.jms.pub-sub-domain 的值来控制，true 为广播模式，false 为队列模式，默认情况下支持队列模式。</p>
<p>如果需要在同一项目中既支持队列模式也支持广播模式，可以通过 DefaultJmsListenerContainerFactory 创建自定义的 JmsListenerContainerFactory 实例，之后在 @JmsListener 注解中通过 containerFactory 属性引用它。</p>
<p>分别创建两个自定义的 JmsListenerContainerFactory 实例，通过 pubSubDomain 来控制是支持队列模式还是广播模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableJms</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveMQConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueListenerFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; queueListenerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        <span class="type">DefaultJmsListenerContainerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultJmsListenerContainerFactory</span>();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        factory.setPubSubDomain(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;topicListenerFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> JmsListenerContainerFactory&lt;?&gt; topicListenerFactory(ConnectionFactory connectionFactory) &#123;</span><br><span class="line">        <span class="type">DefaultJmsListenerContainerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultJmsListenerContainerFactory</span>();</span><br><span class="line">        factory.setConnectionFactory(connectionFactory);</span><br><span class="line">        factory.setPubSubDomain(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>然后在消费者接收的方法中，指明使用 containerFactory 接收消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Consumer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;neo.queue&quot;, containerFactory = &quot;queueListenerFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveQueue</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer queue msg : &quot;</span>+text);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JmsListener(destination = &quot;neo.topic&quot;, containerFactory = &quot;topicListenerFactory&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveTopic</span><span class="params">(String text)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Consumer topic msg : &quot;</span>+text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制</span><br></pre></td></tr></table></figure>

<p>改造完成之后，再次执行队列和广播的测试方法，就会发现项目同时支持了两种类型的消息收发。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>消息中间件广泛应用在大型互联网架构中，利用消息中间件队列和广播各自的特性可以支持很多业务，比如群发发送短信、给单个用户发送邮件等。ActiveMQ 是一款非常流行的消息中间件，它的特点是部署简单、使用方便，比较适合中小型团队。Spring Boot 提供了集成 ActiveMQ 对应的组件，在 Spring Boot 中使用 ActiveMQ 只需要添加相关注解即可。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2020/09/28/Spring%20Boot%20ActiveMQ/" data-id="cll1oa29e000sl9cpf2nv0o86" class="article-share-link">Share</a>
      

      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/29/Spring%20Boot%20MongoDB/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2020/09/28/Spring%20Boot%20Cache/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>

</section>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 Tukeke<br>
      Theme <a href="https://github.com/Tukekehaohaonuli/" target="_blank">Oishi</a>, Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <!--
      <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/categories/life" class="mobile-nav-link">生活</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    -->
    

<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdn.bootcss.com/jquery/1.11.1/jquery.min.js"></script>




<script src="/js/jquery.scrollUp.min.js"></script>


<script src="/js/jquery.transform.js"></script>


<script src="/js/menu.js"></script>



<script src="/js/script.js"></script>


<script src="/js/scrollUp.js"></script>


  </div>
</body>
</html>